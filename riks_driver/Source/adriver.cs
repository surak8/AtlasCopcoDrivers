//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Text;
using Microsoft.CSharp;
using OpenProtocolInterpreter.Communication;

namespace NSRiks_driver {

	public class riks_driverDriver {
		static readonly BindingFlags bfCreate = BindingFlags.CreateInstance | BindingFlags.Public | BindingFlags.DeclaredOnly | BindingFlags.ExactBinding | BindingFlags.Instance | BindingFlags.Static;
		static readonly BindingFlags bfMethod = BindingFlags.Public | BindingFlags.Instance;
		static readonly BindingFlags bfProps = BindingFlags.Public | BindingFlags.Instance | BindingFlags.GetProperty | BindingFlags.DeclaredOnly;

		[STAThread()]
		public static void Main(string[] args) {
			CodeCompileUnit ccu = new CodeCompileUnit();
			//CodeNamespace ns;
			IDictionary<string, CodeNamespace> namespaces;

			namespaces = new Dictionary<string, CodeNamespace>();
			//ccu.Namespaces.Add(ns = new CodeNamespace());
			namespaces.Add(string.Empty, new CodeNamespace());
			testit();

			foreach (Assembly v2 in AppDomain.CurrentDomain.GetAssemblies()) {
				if (string.Compare(v2.GetName().Name, "OpenProtocolInterpreter", true) == 0) {
					foreach (Type aType in v2.GetTypes()) {
						if (aType.IsClass)
							processType(aType, ccu, namespaces);
					}
				}
			}
			showResult(ccu, namespaces);

		}

		static void showResult(CodeCompileUnit ccu, IDictionary<string, CodeNamespace> namespaces) {
			StringBuilder sb;
			CodeGeneratorOptions opts = new CodeGeneratorOptions();

			opts.BlankLinesBetweenMembers = false;
			//opts.BracingStyle = "C";
			opts.ElseOnClosing = true;
			opts.IndentString = "\t";
			opts.VerbatimOrder = false;

			foreach (string aKey in namespaces.Keys)
				ccu.Namespaces.Add(namespaces[aKey]);
			using (StringWriter sw = new System.IO.StringWriter(sb = new StringBuilder())) {
				CodeDomProvider.CreateProvider("c#").GenerateCodeFromCompileUnit(ccu, sw, opts);
			}
			//CSharpCodeProvider.CreateProvider().GenerateCodeFromCompileUnit(ccu,)
			Trace.WriteLine(sb.ToString());
		}

		static void processType(Type aType, CodeCompileUnit ccu, IDictionary<string, CodeNamespace> namespaces) {
			//string tmp, nsName;
			object anObj;
			object[] ctorArgs = new object[] { };
			CodeNamespace ns;
			CodeTypeDeclaration ctd;


			if (isTypeAttribute(aType.Attributes, TypeAttributes.Public)) {
				if (aType.Name.StartsWith("Mid0")) {
					try {
						ns = addNamespaceIfNeeded(aType, namespaces, ccu);
						if (ns == null) {
							Debug.WriteLine("ack: error here");
							return;
						}
						ns.Types.Add(ctd = new CodeTypeDeclaration(aType.Name));
						anObj = aType.InvokeMember(null, bfCreate, null, null, ctorArgs);
						//foreach (var avar in aType.GetMethods(bfMethod)) {
						//	if (isMethodAttribute(avar.Attributes, MethodAttributes.SpecialName)) {
						//		Trace.WriteLine("here");
						//	}
						//}
						generatePropertyInfo(aType, ctd);
					} catch (Exception ex) {
						Trace.WriteLine(ex.Message);

					}
				}
			}
		}

		  static void generatePropertyInfo(Type aType, CodeTypeDeclaration ctd) {
			CodeMemberProperty p;
			MethodInfo miget;
			CodeMemberField f;

			foreach (var avar in aType.GetProperties(bfProps)) {
				ctd.Members.AddRange(new CodeTypeMember[] {
					f = new CodeMemberField(
							new CodeTypeReference(avar.PropertyType.FullName),
							makePropertyName(avar.Name)),
					p=new  CodeMemberProperty()
				});

				if ((miget = avar.GetGetMethod()) != null) {
					p.HasGet = true;
					if (miget.IsPublic) {
						p.Attributes ^= MemberAttributes.Private;
						p.Attributes |= MemberAttributes.Public;
					}
				}
				if (avar.GetSetMethod() != null) {
					p.HasSet = true;
				}
				p.Name = avar.Name;
				p.Type = new CodeTypeReference(avar.PropertyType.FullName);
				p.Type = f.Type;
			}
		}

		static string makePropertyName(string name) {
			StringBuilder sb;
			if (!string.IsNullOrEmpty(name)) {
				sb = new StringBuilder();
				sb.Append(name.Substring(0, 1).ToLower());
				for(int i = 1; i < name.Length; i++) {
					sb.Append(name[i], 1);
				}
				return sb.ToString();
			}
			return string.Empty;
		}

		static CodeNamespace addNamespaceIfNeeded(Type aType, IDictionary<string, CodeNamespace> namespaces, CodeCompileUnit ccu) {
			int pos;
			string typeName, nsName, className;
			CodeNamespace ns = null;

			if ((pos = (typeName = aType.FullName).IndexOf(className = aType.Name, 0, typeName.Length)) < 0) {
				Trace.WriteLine("error here");
				return null;
			}
			if (!namespaces.ContainsKey(nsName = typeName.Substring(0, pos - 1))) {
				ccu.Namespaces.Add(ns = new CodeNamespace(nsName));
				namespaces.Add(nsName, ns);
			} else
				ns = namespaces[nsName];
			return ns;
		}

		static void testit() {
			var m02 = new OpenProtocolInterpreter.Communication.Mid0002();
			m02.CellId = 1000;
			m02.ChannelId = 1001;
			m02.ControllerName = "rik_controller";
			m02.ControllerSerialNumber = "csn";
			m02.ControllerSoftwareVersion = "V99";
			m02.LinkingHandlingSupport = true;
			m02.OpenProtocolVersion = "blah";
			m02.RBUType = "rbu0";
			m02.SequenceNumberSupport = true;
			m02.SupplierCode = "supplier";
			m02.SystemSubType = OpenProtocolInterpreter.SystemSubType.NORMAL_TIGHTENING_SYSTEM;
			m02.SystemType = OpenProtocolInterpreter.SystemType.POWER_FOCUS_6000;
			m02.ToolSoftwareVersion = "tswV0";
			string dataPackage;
			dataPackage = m02.Pack();
			var m02_test = new OpenProtocolInterpreter.Communication.Mid0002();
			var test = m02_test.Parse(dataPackage);
			//m02_test.
			string blah;
			blah = test.Pack();
			if (string.Compare(dataPackage, blah, 0) != 0) {
				Trace.WriteLine("difference!");
			}
			Trace.WriteLine("here");
		}

		static bool isTypeAttribute(TypeAttributes ta, TypeAttributes taSearch) { return (ta & taSearch) == taSearch; }
		static bool isMethodAttribute(MethodAttributes ma, MethodAttributes maSearch) { return (ma & maSearch) == maSearch; }
	}
}